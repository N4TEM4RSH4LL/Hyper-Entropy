<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HYPER-ENTROPY</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Orbitron:wght@400;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', sans-serif;
            touch-action: none; /* Prevent pull-to-refresh on mobile */
            cursor: none; /* Custom cursor handling */
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        #score-board {
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
            color: #fff;
            font-size: 2rem;
            font-weight: 900;
        }

        #chaos-meter {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            overflow: hidden;
        }

        #chaos-fill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #f0f, #0ff);
            transition: width 0.1s linear;
        }

        #message-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
            pointer-events: auto;
            cursor: pointer;
        }

        h1 {
            font-family: 'Black Ops One', cursive;
            font-size: 5rem;
            margin: 0;
            letter-spacing: 5px;
            animation: glitch 1s infinite;
        }

        p {
            font-size: 1.2rem;
            color: #aaa;
        }

        .hidden {
            display: none !important;
        }

        /* Glitch Animation */
        @keyframes glitch {
            0% { text-shadow: 2px 2px #ff00ff, -2px -2px #00ffff; transform: translate(0,0); }
            20% { text-shadow: -2px 2px #ff00ff, 2px -2px #00ffff; transform: translate(-2px, 2px); }
            40% { text-shadow: 2px -2px #ff00ff, -2px 2px #00ffff; transform: translate(2px, -2px); }
            60% { text-shadow: -2px -2px #ff00ff, 2px 2px #00ffff; transform: translate(0,0); }
            80% { text-shadow: 2px 2px #ff00ff, -2px -2px #00ffff; transform: translate(-1px, -1px); }
            100% { text-shadow: 2px 2px #ff00ff, -2px -2px #00ffff; transform: translate(0,0); }
        }

        #glitch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: overlay;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="score-board">ENTROPY: 0</div>
        <div id="chaos-meter"><div id="chaos-fill"></div></div>
    </div>

    <div id="message-overlay">
        <h1>HYPER<br>ENTROPY</h1>
        <p>[ CLICK TO INITIATE CHAOS ]</p>
        <p style="font-size: 0.8rem; margin-top: 20px;">Use MOUSE to control the Singularity.<br>Absorb NEON. Avoid RED/GLITCH.</p>
    </div>

    <div id="glitch-overlay"></div>
    <canvas id="gameCanvas"></canvas>

<script>
/**
 * HYPER-ENTROPY
 * A procedural arcade chaos engine.
 */

// --- Audio Engine (Synthesized) ---
const AudioEngine = {
    ctx: null,
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone: function(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        // Pitch drop effect
        osc.frequency.exponentialRampToValueAtTime(freq * 0.5, this.ctx.currentTime + duration);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playCollect: function() {
        // High pitched satisfying 'ping'
        this.playTone(800 + Math.random() * 400, 'sine', 0.2, 0.15);
        this.playTone(1200, 'triangle', 0.1, 0.05);
    },
    playExplosion: function() {
        // Low rumble
        this.playTone(100, 'sawtooth', 0.4, 0.2);
        this.playTone(50, 'square', 0.5, 0.2);
    },
    playChaos: function() {
        // Glitchy noise
        for(let i=0; i<5; i++) {
            setTimeout(() => this.playTone(200 + Math.random()*1000, 'sawtooth', 0.1, 0.1), i*50);
        }
    }
};

// --- Utilities ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiScore = document.getElementById('score-board');
const chaosFill = document.getElementById('chaos-fill');
const msgOverlay = document.getElementById('message-overlay');
const glitchDiv = document.getElementById('glitch-overlay');

let width, height;
const resize = () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
};
window.addEventListener('resize', resize);
resize();

// Vector Math
class Vec2 {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; return this; }
    mult(n) { this.x *= n; this.y *= n; return this; }
    div(n) { this.x /= n; this.y /= n; return this; }
    mag() { return Math.sqrt(this.x*this.x + this.y*this.y); }
    normalize() { let m = this.mag(); if(m!=0) this.div(m); return this; }
    clone() { return new Vec2(this.x, this.y); }
    dist(v) { return Math.sqrt(Math.pow(this.x-v.x, 2) + Math.pow(this.y-v.y, 2)); }
}

// --- Game Classes ---

class Grid {
    constructor() {
        this.spacing = 40;
        this.points = [];
        this.cols = 0;
        this.rows = 0;
        this.init();
    }

    init() {
        this.points = [];
        this.cols = Math.ceil(width / this.spacing) + 2;
        this.rows = Math.ceil(height / this.spacing) + 2;
        for (let y = 0; y < this.rows; y++) {
            for (let x = 0; x < this.cols; x++) {
                this.points.push({
                    baseX: x * this.spacing,
                    baseY: y * this.spacing,
                    x: x * this.spacing,
                    y: y * this.spacing,
                    vx: 0,
                    vy: 0
                });
            }
        }
    }

    update(player) {
        // Spring physics for grid points
        for (let p of this.points) {
            // Hooke's Law (return to base)
            let dx = p.x - p.baseX;
            let dy = p.y - p.baseY;
            let ax = -0.05 * dx;
            let ay = -0.05 * dy;

            // Repel/Attract from player (Warp effect)
            let dist = Math.sqrt((p.x - player.pos.x)**2 + (p.y - player.pos.y)**2);
            if (dist < 300) {
                let force = (300 - dist) / 300;
                let dirX = (p.x - player.pos.x) / dist;
                let dirY = (p.y - player.pos.y) / dist;
                // Warp inward
                ax -= dirX * force * 15;
                ay -= dirY * force * 15;
            }

            p.vx += ax;
            p.vy += ay;
            p.vx *= 0.85; // Damping
            p.vy *= 0.85;
            p.x += p.vx;
            p.y += p.vy;
        }
    }

    draw(ctx) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        // Draw horizontal lines
        for (let y = 0; y < this.rows; y++) {
             // simplified drawing for performance: connecting points
            let startIdx = y * this.cols;
            ctx.moveTo(this.points[startIdx].x, this.points[startIdx].y);
            for (let x = 1; x < this.cols; x++) {
                let p = this.points[startIdx + x];
                ctx.lineTo(p.x, p.y);
            }
        }
        // Draw vertical lines
        for (let x = 0; x < this.cols; x++) {
            let startIdx = x;
            ctx.moveTo(this.points[startIdx].x, this.points[startIdx].y);
            for (let y = 1; y < this.rows; y++) {
                let p = this.points[y * this.cols + x];
                ctx.lineTo(p.x, p.y);
            }
        }
        ctx.stroke();
    }
}

class Particle {
    constructor(x, y, color, speed = 1, life = 1.0) {
        this.pos = new Vec2(x, y);
        const angle = Math.random() * Math.PI * 2;
        const velMag = Math.random() * 2 * speed;
        this.vel = new Vec2(Math.cos(angle) * velMag, Math.sin(angle) * velMag);
        this.life = life;
        this.decay = Math.random() * 0.02 + 0.01;
        this.color = color;
        this.size = Math.random() * 3 + 1;
    }
    update() {
        this.pos.add(this.vel);
        this.life -= this.decay;
        this.vel.mult(0.95); // Friction
    }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life;
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Entity {
    constructor(type) {
        // type: 'good', 'bad', 'floater'
        this.type = type;
        
        // Spawn at edges
        if (Math.random() < 0.5) {
            this.pos = new Vec2(Math.random() < 0.5 ? -20 : width + 20, Math.random() * height);
        } else {
            this.pos = new Vec2(Math.random() * width, Math.random() < 0.5 ? -20 : height + 20);
        }

        this.vel = new Vec2(0, 0);
        this.acc = new Vec2(0, 0);
        this.size = type === 'boss' ? 40 : (10 + Math.random() * 10);
        this.angle = 0;
        this.spin = (Math.random() - 0.5) * 0.2;
        
        if (type === 'good') {
            this.color = `hsl(${Math.random()*60 + 180}, 100%, 50%)`; // Cyans/Blues
        } else if (type === 'bad') {
            this.color = `hsl(${Math.random()*30 + 340}, 100%, 50%)`; // Reds/Pinks
        } else {
            this.color = `hsl(${Math.random()*360}, 100%, 80%)`;
        }
    }

    update(player) {
        let dir = new Vec2(player.pos.x - this.pos.x, player.pos.y - this.pos.y);
        let dist = dir.mag();
        dir.normalize();

        // Behavior
        if (this.type === 'good') {
            // Seek player slightly, swirl
            dir.mult(0.2); 
            // Add perpendicular swirl
            this.acc.add(dir);
            this.acc.add(new Vec2(-dir.y, dir.x).mult(0.5));
        } else if (this.type === 'bad') {
            // Aggressive tracking
            dir.mult(0.35);
            this.acc.add(dir);
        }

        this.vel.add(this.acc);
        this.vel.mult(0.96);
        this.pos.add(this.vel);
        this.acc.mult(0);
        this.angle += this.spin;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(this.angle);
        
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;

        if (this.type === 'good') {
            // Triangle
            ctx.beginPath();
            ctx.moveTo(this.size, 0);
            ctx.lineTo(-this.size/2, this.size/2);
            ctx.lineTo(-this.size/2, -this.size/2);
            ctx.fill();
        } else if (this.type === 'bad') {
            // Spiky square
            ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
            // Draw X
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-this.size/4, -this.size/4);
            ctx.lineTo(this.size/4, this.size/4);
            ctx.moveTo(this.size/4, -this.size/4);
            ctx.lineTo(-this.size/4, this.size/4);
            ctx.stroke();
        }
        
        ctx.restore();
    }
}

// --- Game Engine ---

const Game = {
    running: false,
    score: 0,
    frames: 0,
    chaosLevel: 0,
    currentChaosMode: 'NORMAL',
    chaosTimer: 0,
    screenShake: 0,
    
    player: {
        pos: new Vec2(window.innerWidth/2, window.innerHeight/2),
        size: 15,
        trail: []
    },
    
    entities: [],
    particles: [],
    grid: null,
    texts: [],

    init: function() {
        this.grid = new Grid();
        
        // Input Handling
        window.addEventListener('mousemove', e => {
            if(this.running) {
                // Lerp towards mouse for smoother feel
                this.targetPos = new Vec2(e.clientX, e.clientY);
            }
        });
        window.addEventListener('touchmove', e => {
            e.preventDefault();
            if(this.running) {
                this.targetPos = new Vec2(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});

        this.targetPos = this.player.pos.clone();
    },

    start: function() {
        this.running = true;
        this.score = 0;
        this.entities = [];
        this.particles = [];
        this.chaosLevel = 0;
        this.chaosTimer = 0;
        this.currentChaosMode = 'NORMAL';
        msgOverlay.classList.add('hidden');
        uiScore.innerHTML = "ENTROPY: 0";
        AudioEngine.init();
        AudioEngine.playCollect(); // Startup sound
        this.loop();
    },

    triggerChaos: function() {
        const modes = ['GRAVITY_FLIP', 'SLOW_MO', 'HYPER_SPEED', 'DISCO', 'INVERT', 'GIANT'];
        this.currentChaosMode = modes[Math.floor(Math.random() * modes.length)];
        
        this.spawnText("PROTOCOL: " + this.currentChaosMode, width/2, height/3, 50, '#f0f');
        AudioEngine.playChaos();
        this.screenShake = 20;

        // Visual effects based on mode
        if(this.currentChaosMode === 'INVERT') {
            document.body.style.filter = 'invert(1)';
        } else {
            document.body.style.filter = 'none';
        }

        setTimeout(() => {
            this.currentChaosMode = 'NORMAL';
            document.body.style.filter = 'none';
        }, 5000); // Chaos lasts 5 seconds
    },

    spawnText: function(str, x, y, size, color) {
        this.texts.push({
            str, x, y, size, color, life: 1.0, vy: -2
        });
    },

    gameOver: function() {
        this.running = false;
        msgOverlay.classList.remove('hidden');
        msgOverlay.innerHTML = `<h1>SYNC LOST</h1><p>FINAL ENTROPY: ${this.score}</p><p>[ CLICK TO REBOOT ]</p>`;
        AudioEngine.playExplosion();
    },

    update: function() {
        // Player Movement (Lerp)
        let lerpFactor = 0.15;
        if(this.currentChaosMode === 'HYPER_SPEED') lerpFactor = 0.4;
        if(this.currentChaosMode === 'SLOW_MO') lerpFactor = 0.05;
        
        this.player.pos.x += (this.targetPos.x - this.player.pos.x) * lerpFactor;
        this.player.pos.y += (this.targetPos.y - this.player.pos.y) * lerpFactor;

        // Trail
        if(this.frames % 2 === 0) {
            this.player.trail.push(this.player.pos.clone());
            if(this.player.trail.length > 20) this.player.trail.shift();
        }

        // Chaos Meter
        this.chaosTimer++;
        let chaosThreshold = 600; // 10 seconds at 60fps
        chaosFill.style.width = (this.chaosTimer / chaosThreshold * 100) + '%';
        if(this.chaosTimer >= chaosThreshold) {
            this.triggerChaos();
            this.chaosTimer = 0;
        }

        // Spawning
        if(Math.random() < 0.03 + (this.score * 0.0001)) {
            let type = Math.random() > 0.3 ? 'good' : 'bad';
            if (this.currentChaosMode === 'DISCO') type = 'good'; // Bonus round
            this.entities.push(new Entity(type));
        }

        // Entity Logic
        for(let i = this.entities.length - 1; i >= 0; i--) {
            let e = this.entities[i];
            e.update(this.player);

            // Collision
            let dist = this.player.pos.dist(e.pos);
            let collisionDist = this.player.size + e.size;
            
            // Giant Mode hit box
            if(this.currentChaosMode === 'GIANT') collisionDist += 50;

            if(dist < collisionDist) {
                // HIT
                if(e.type === 'good') {
                    this.score += 100;
                    this.chaosTimer += 20; // Charge chaos faster
                    AudioEngine.playCollect();
                    this.spawnParticles(e.pos.x, e.pos.y, e.color, 10);
                    this.spawnText("+100", e.pos.x, e.pos.y, 20, '#fff');
                } else {
                    if (this.currentChaosMode !== 'GIANT') {
                        this.screenShake = 10;
                        this.score -= 50;
                        AudioEngine.playExplosion();
                        this.spawnParticles(e.pos.x, e.pos.y, '#f00', 20);
                        if(this.score < 0) this.gameOver();
                    } else {
                        // Eat bad guys in giant mode
                        this.score += 200;
                        AudioEngine.playCollect();
                        this.spawnParticles(e.pos.x, e.pos.y, '#f0f', 15);
                        this.spawnText("CRUNCH", e.pos.x, e.pos.y, 30, '#f00');
                    }
                }
                this.entities.splice(i, 1);
            } else if (e.pos.x < -100 || e.pos.x > width+100 || e.pos.y < -100 || e.pos.y > height+100) {
                 this.entities.splice(i, 1);
            }
        }

        // Particles
        for(let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.update();
            if(p.life <= 0) this.particles.splice(i, 1);
        }

        // Grid
        this.grid.update(this.player);

        // Shake Decay
        if(this.screenShake > 0) this.screenShake *= 0.9;
        if(this.screenShake < 0.5) this.screenShake = 0;

        // Update UI
        uiScore.innerText = `ENTROPY: ${this.score}`;
        
        this.frames++;
    },

    spawnParticles: function(x, y, color, count) {
        for(let i=0; i<count; i++) {
            this.particles.push(new Particle(x, y, color, 2));
        }
    },

    draw: function() {
        // Clear with trails
        ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
        ctx.fillRect(0, 0, width, height);

        // Screen Shake
        ctx.save();
        if(this.screenShake > 0) {
            let dx = (Math.random() - 0.5) * this.screenShake;
            let dy = (Math.random() - 0.5) * this.screenShake;
            ctx.translate(dx, dy);
        }

        // Draw Grid
        this.grid.draw(ctx);

        // Draw Player Trail
        ctx.beginPath();
        if(this.player.trail.length > 0) {
            ctx.moveTo(this.player.trail[0].x, this.player.trail[0].y);
            for(let p of this.player.trail) ctx.lineTo(p.x, p.y);
            ctx.strokeStyle = this.currentChaosMode === 'GIANT' ? '#ff00ff' : '#00ffff';
            ctx.lineWidth = this.player.size;
            ctx.lineCap = 'round';
            ctx.shadowBlur = 20;
            ctx.shadowColor = ctx.strokeStyle;
            ctx.stroke();
        }

        // Draw Player Head
        ctx.fillStyle = '#fff';
        ctx.shadowBlur = 30;
        ctx.shadowColor = '#fff';
        let size = this.player.size;
        if(this.currentChaosMode === 'GIANT') size = 60;
        
        ctx.beginPath();
        ctx.arc(this.player.pos.x, this.player.pos.y, size, 0, Math.PI*2);
        ctx.fill();

        // Draw Entities
        // Use composite operation for neon look
        ctx.globalCompositeOperation = 'lighter';
        for(let e of this.entities) e.draw(ctx);
        for(let p of this.particles) p.draw(ctx);
        ctx.globalCompositeOperation = 'source-over';

        // Draw Texts
        for(let i = this.texts.length-1; i>=0; i--) {
            let t = this.texts[i];
            ctx.font = `900 ${t.size}px Orbitron`;
            ctx.fillStyle = t.color;
            ctx.globalAlpha = t.life;
            ctx.textAlign = 'center';
            ctx.shadowBlur = 10;
            ctx.shadowColor = t.color;
            ctx.fillText(t.str, t.x, t.y);
            
            t.y += t.vy;
            t.life -= 0.02;
            if(t.life <= 0) this.texts.splice(i, 1);
        }
        ctx.globalAlpha = 1.0;

        ctx.restore();
    },

    loop: function() {
        if(!this.running) return;
        this.update();
        this.draw();
        requestAnimationFrame(() => this.loop());
    }
};

// Start Interaction
Game.init();
msgOverlay.addEventListener('click', () => {
    Game.start();
});

// Initial Grid Draw
const tempGrid = new Grid();
function idleLoop() {
    if(Game.running) return;
    ctx.fillStyle = 'rgba(5,5,5,0.1)';
    ctx.fillRect(0,0,width,height);
    tempGrid.update({pos: {x: -1000, y: -1000}}); // No player
    tempGrid.draw(ctx);
    requestAnimationFrame(idleLoop);
}
idleLoop();

</script>
</body>
</html>